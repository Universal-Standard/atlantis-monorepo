name: Automated Review and Merge

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request number to review and merge'
        required: true
        type: string
  pull_request:
    types: [opened, synchronize, labeled]

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write
  actions: write

jobs:
  automated-review:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      contains(github.event.pull_request.labels.*.name, 'automated-fix')
    steps:
      - name: Get PR Details
        id: pr-details
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.inputs?.pr_number || context.payload.pull_request?.number;
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber)
            });
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_title', pr.data.title);
            core.setOutput('pr_branch', pr.data.head.ref);
            core.setOutput('pr_sha', pr.data.head.sha);
            
            // Add review started comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber),
              body: 'ðŸ” **Automated Review Started**\n\nPerforming comprehensive automated review of changes...'
            });

      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-details.outputs.pr_sha }}
          fetch-depth: 0

      - name: Setup Review Environment
        run: |
          # Install common tools for code analysis
          sudo apt-get update -q
          sudo apt-get install -y -q jq shellcheck
          
          # Setup for multiple languages
          echo "Review environment ready"

      - name: Run Code Quality Checks
        id: quality-checks
        continue-on-error: true
        run: |
          echo "Running code quality checks..."
          
          ISSUES_FOUND=0
          
          # Check shell scripts if any
          if find . -name "*.sh" -type f | grep -q .; then
            echo "Checking shell scripts..."
            if ! find . -name "*.sh" -type f -exec shellcheck {} \; ; then
              echo "Shell script issues found"
              ISSUES_FOUND=$((ISSUES_FOUND + 1))
            fi
          fi
          
          # Check for common code issues
          echo "Checking for common issues..."
          
          # Check for trailing whitespace
          if git diff origin/main --check ; then
            echo "No trailing whitespace found"
          else
            echo "Trailing whitespace found"
            ISSUES_FOUND=$((ISSUES_FOUND + 1))
          fi
          
          # Check for large files
          if find . -type f -size +1M -not -path "./.git/*" | grep -q .; then
            echo "Large files detected"
            find . -type f -size +1M -not -path "./.git/*"
          fi
          
          echo "quality_issues=$ISSUES_FOUND" >> $GITHUB_OUTPUT

      - name: Security Scan
        id: security-scan
        continue-on-error: true
        run: |
          echo "Running security scan..."
          
          SECURITY_ISSUES=0
          
          # Check for potential secrets in changed files with assignment-like patterns
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD || git diff --name-only origin/main || echo "")
          
          if [ -n "$CHANGED_FILES" ]; then
            # Exclude documentation and config template files
            SECRET_SCAN_FILES=$(echo "$CHANGED_FILES" | grep -Ev '\.(md|markdown|rst|txt|example|sample|template)$' || true)
          else
            SECRET_SCAN_FILES=""
          fi
          
          if [ -n "$SECRET_SCAN_FILES" ]; then
            echo "Scanning changed files for hard-coded secrets with assignment patterns..."
            # Look for patterns like password="value", api_key = "value", token: "value"
            if echo "$SECRET_SCAN_FILES" | xargs grep -E '(password|secret|api[_-]?key|token|credentials)\s*[:=]\s*["\047][^"\047[:space:]]{8,}["\047]' 2>/dev/null | grep -v -E '(example|sample|placeholder|your_|xxx|yyy|zzz|\*\*\*|test)' >/tmp/secret_scan_matches; then
              echo "âš ï¸ Potential hard-coded secrets detected in the following locations:"
              cat /tmp/secret_scan_matches
              SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
            else
              echo "âœ“ No potential hard-coded secrets detected in changed files"
            fi
          else
            echo "No relevant changed files to scan for secrets"
          fi
          
          echo "security_issues=$SECURITY_ISSUES" >> $GITHUB_OUTPUT

      - name: Documentation Check
        id: doc-check
        run: |
          echo "Checking documentation..."
          
          DOC_ISSUES=0
          
          # Check if new files need documentation
          NEW_FILES=$(git diff --name-only origin/main)
          
          echo "New or modified files:"
          echo "$NEW_FILES"
          
          echo "doc_issues=$DOC_ISSUES" >> $GITHUB_OUTPUT

      - name: Generate Review Report
        id: review-report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const qualityIssues = parseInt('${{ steps.quality-checks.outputs.quality_issues }}' || '0');
            const securityIssues = parseInt('${{ steps.security-scan.outputs.security_issues }}' || '0');
            const docIssues = parseInt('${{ steps.doc-check.outputs.doc_issues }}' || '0');
            
            const totalIssues = qualityIssues + securityIssues + docIssues;
            
            let reviewBody = '## ðŸ¤– Automated Review Report\n\n';
            reviewBody += '### Summary\n\n';
            
            if (totalIssues === 0) {
              reviewBody += 'âœ… **All automated checks passed!**\n\n';
              reviewBody += '- Code quality: âœ… Passed\n';
              reviewBody += '- Security scan: âœ… Passed\n';
              reviewBody += '- Documentation: âœ… Adequate\n';
              core.setOutput('approved', 'true');
            } else {
              reviewBody += `âš ï¸ **${totalIssues} issue(s) detected**\n\n`;
              reviewBody += `- Code quality: ${qualityIssues === 0 ? 'âœ…' : 'âš ï¸'} (${qualityIssues} issues)\n`;
              reviewBody += `- Security scan: ${securityIssues === 0 ? 'âœ…' : 'âš ï¸'} (${securityIssues} issues)\n`;
              reviewBody += `- Documentation: ${docIssues === 0 ? 'âœ…' : 'âš ï¸'} (${docIssues} issues)\n`;
              core.setOutput('approved', 'false');
            }
            
            reviewBody += '\n### Next Steps\n\n';
            if (totalIssues === 0) {
              reviewBody += 'This PR is ready for automated merge. ðŸš€\n';
            } else {
              reviewBody += 'Issues will be auto-fixed in the next iteration.\n';
            }
            
            core.setOutput('review_body', reviewBody);
            return reviewBody;

      - name: Post Review Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-details.outputs.pr_number }};
            const reviewBody = `${{ steps.review-report.outputs.review_body }}`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber),
              body: reviewBody
            });

      - name: Approve PR
        if: steps.review-report.outputs.approved == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-details.outputs.pr_number }};
            
            // Create approval review
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(prNumber),
                event: 'APPROVE',
                body: 'âœ… Automated review complete. All checks passed. Approving for merge.'
              });
            } catch (error) {
              console.log('Could not create review (may be author):', error.message);
              // Note: This is expected when the workflow author is the PR author
              // The PR will still be approved via labels and can be merged
            }
            
            // Add approval label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber),
              labels: ['approved', 'ready-to-merge']
            });

  automated-merge:
    needs: automated-review
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      contains(github.event.pull_request.labels.*.name, 'automated-fix')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get PR Details
        id: pr-details
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.inputs?.pr_number || context.payload.pull_request?.number;
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber)
            });
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_branch', pr.data.head.ref);
            core.setOutput('pr_mergeable', pr.data.mergeable);
            
            return pr.data;

      - name: Wait for Checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-details.outputs.pr_number }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            
            const maxAttempts = 60; // ~30 minutes with a 30s interval
            const intervalMs = 30000;
            
            function checksIndicateFailure(checkRuns) {
              if (!checkRuns || checkRuns.length === 0) {
                return false;
              }
              const failingConclusions = ['failure', 'cancelled', 'timed_out', 'action_required', 'stale'];
              return checkRuns.some((run) => run.conclusion && failingConclusions.includes(run.conclusion));
            }
            
            function allChecksCompleted(checkRuns) {
              if (!checkRuns || checkRuns.length === 0) {
                return true; // If no checks, consider them complete
              }
              return checkRuns.every((run) => run.status === 'completed');
            }
            
            console.log(`Waiting for checks to complete for PR #${prNumber}...`);
            
            let attempt = 0;
            while (attempt < maxAttempts) {
              attempt += 1;
              console.log(`Check polling attempt ${attempt}/${maxAttempts}...`);
              
              // Get latest PR data to obtain the current head SHA
              const { data: pr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });
              
              const headSha = pr.head && pr.head.sha;
              if (!headSha) {
                console.log('Unable to determine head SHA, waiting before retrying...');
                await delay(intervalMs);
                continue;
              }
              
              // Combined status for the ref (includes legacy statuses)
              const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
                owner,
                repo,
                ref: headSha,
              });
              
              const state = combinedStatus.data.state; // success, failure, pending, error
              console.log(`Combined status for ${headSha}: ${state}`);
              
              // Check runs API (more granular)
              let checkRuns = [];
              try {
                const checksResponse = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: headSha,
                });
                checkRuns = checksResponse.data.check_runs || [];
                console.log(`Found ${checkRuns.length} check runs for ${headSha}.`);
              } catch (e) {
                console.log(`Checks API not available or error: ${e.message}`);
              }
              
              const hasFailingChecks = checksIndicateFailure(checkRuns) || state === 'failure' || state === 'error';
              if (hasFailingChecks) {
                core.setFailed(`One or more required checks have failed for PR #${prNumber}.`);
                return;
              }
              
              const checksCompleted =
                (checkRuns.length > 0 && allChecksCompleted(checkRuns) && (state === 'success' || state === 'pending')) ||
                (checkRuns.length === 0 && (state === 'success' || state === 'pending'));
              
              if (checksCompleted) {
                console.log('âœ“ All checks have completed successfully. Proceeding to merge step.');
                return;
              }
              
              if (attempt >= maxAttempts) {
                core.setFailed(`Timed out waiting for checks to complete for PR #${prNumber}.`);
                return;
              }
              
              console.log(`Checks not yet complete; waiting ${intervalMs / 1000}s before next poll...`);
              await delay(intervalMs);
            }
            
            core.setFailed(`Timed out waiting for checks to complete for PR #${prNumber}.`);

      - name: Merge Pull Request
        id: merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-details.outputs.pr_number }};
            
            try {
              // Attempt to merge
              const merge = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(prNumber),
                commit_title: `ðŸ¤– Auto-merge: PR #${prNumber}`,
                commit_message: 'Automatically merged by automated workflow system',
                merge_method: 'squash'
              });
              
              console.log('PR merged successfully');
              core.setOutput('merged', 'true');
              core.setOutput('merge_sha', merge.data.sha);
              
              return merge.data;
            } catch (error) {
              console.log('Merge failed:', error.message);
              core.setOutput('merged', 'false');
              core.setOutput('error', error.message);
              
              // Add comment about merge failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(prNumber),
                body: `âš ï¸ **Automated Merge Failed**\n\nReason: ${error.message}\n\nThe system will retry or require manual intervention.`
              });
              
              throw error;
            }

      - name: Close Related Issue
        if: steps.merge.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-details.outputs.pr_number }};
            
            // Get PR to find related issue
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber)
            });
            
            // Extract issue number from PR body using GitHub closing keywords
            const prBody = pr.data.body || '';
            const issueMatch = prBody.match(/\b(?:fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)\s+#(\d+)/i);
            if (issueMatch) {
              const issueNumber = parseInt(issueMatch[1]);
              
              // Close the issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: 'closed'
              });
              
              // Add final comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `âœ… **Issue Resolved and Merged**\n\nThis issue has been automatically resolved and merged to main.\n\n- PR #${prNumber} merged successfully\n- Changes are now live in main branch\n- Issue automatically closed\n\n**Automated workflow complete!** ðŸŽ‰`
              });
              
              console.log(`Closed issue #${issueNumber}`);
            }

      - name: Cleanup Branch
        if: steps.merge.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branch = '${{ steps.pr-details.outputs.pr_branch }}';
            
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${branch}`
              });
              console.log(`Deleted branch: ${branch}`);
            } catch (error) {
              console.log('Branch cleanup failed:', error.message);
            }

      - name: Archive Documentation
        if: steps.merge.outputs.merged == 'true'
        run: |
          echo "Creating archive documentation..."
          mkdir -p .github/archived-resolutions
          
          PR_NUMBER="${{ steps.pr-details.outputs.pr_number }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          cat > .github/archived-resolutions/pr-${PR_NUMBER}.md << EOF
          # PR #${PR_NUMBER} - Automated Resolution
          
          **Merged:** ${TIMESTAMP}
          **Merge SHA:** ${{ steps.merge.outputs.merge_sha }}
          
          ## Summary
          This PR was automatically generated, reviewed, and merged by the automated workflow system.
          
          **Automated Process:**
          1. âœ… Issue detected
          2. âœ… Solution generated
          3. âœ… Changes applied
          4. âœ… Automated review
          5. âœ… Merged to main
          6. âœ… Archived
          
          EOF
          
          # Commit archive documentation to repository
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          git add ".github/archived-resolutions/pr-${PR_NUMBER}.md"
          
          # Commit only if there are staged changes
          if ! git diff --cached --quiet; then
            git commit -m "chore: archive auto-merged PR #${PR_NUMBER}"
            git push
            echo "âœ“ Archive documentation committed and pushed"
          else
            echo "No changes to commit for archive documentation"
          fi

      - name: Post-Merge Notification
        if: steps.merge.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr-details.outputs.pr_number }};
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber),
              body: `ðŸŽ‰ **Successfully Merged and Archived**\n\n**Merge SHA:** \`${{ steps.merge.outputs.merge_sha }}\`\n\nThis PR has completed the full automated workflow:\n- âœ… Detected issue\n- âœ… Generated solution\n- âœ… Applied fix\n- âœ… Automated review\n- âœ… Merged to main\n- âœ… Archived documentation\n- âœ… Closed related issue\n- âœ… Cleaned up branch\n\n**All automated. All self-healing. Mission accomplished!** ðŸš€`
            });
